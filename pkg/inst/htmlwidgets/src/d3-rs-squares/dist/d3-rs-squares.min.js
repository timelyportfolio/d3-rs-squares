(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-time-format'), require('d3-array'), require('d3-collection'), require('d3-time'), require('d3-scale')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-time-format', 'd3-array', 'd3-collection', 'd3-time', 'd3-scale'], factory) :
	(factory((global.d3_rs_squares = {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Selection,d3TimeFormat,d3Array,d3Collection,d3Time,d3Scale) { 'use strict';

var version = "0.8.0";

function svg(id) {
  
  var width = 300,
      height = 150,
      top = 16,
      right = 16,
      bottom = 16,
      left = 16,
      scale = 1,
      inner = 'g.svg-child',
      innerWidth = -1,
      innerHeight = -1,
      style = null,
      background = null,
      title = null,
      desc = null,
      role = 'img',
      classed = 'svg-svg';

  function _updateInnerWidth() {
      innerWidth = width - left - right;
  }    
  
  function _updateInnerHeight() {
      innerHeight = height - top - bottom;
  }   
  
  _updateInnerWidth();
  _updateInnerHeight();
        
  function _impl(context) {
    var selection = context.selection ? context.selection() : context,
        transition = (context.selection !== undefined);

    selection.each(function() {
      var parent = d3Selection.select(this);

      var el = parent.select(_impl.self());
      if (el.empty()) {
        var ariaTitle = (id == null ? '' : id + '-') + 'title';
        var ariaDesc = (id == null ? '' : id + '-') + 'desc';   
        el = parent.append('svg')
                    .attr('version', '1.1')
                    .attr('xmlns', 'http://www.w3.org/2000/svg')
                    .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink') // d3 work around for xlink not required as per D3 4.0
                    .attr('preserveAspectRatio', 'xMidYMid meet')
                    .attr('aria-labelledby', ariaTitle)
                    .attr('aria-describedby', ariaDesc)
                    .attr('id', id);
                    
        el.append('title').attr('id', ariaTitle);        
        el.append('desc').attr('id', ariaDesc);      
        el.append('defs');
        el.append('rect').attr('class', 'background');
        el.append('g').attr('class', 'svg-child');
      }
      
      var defsEl = el.select('defs');
      
      var styleEl = defsEl.selectAll('style').data(style ? [ style ] : []);
      styleEl.exit().remove();
      styleEl = styleEl.enter().append('style').attr('type', 'text/css').merge(styleEl);
      styleEl.text(style);
      
      el.attr('role', role);
      
      el.select('title').text(title);
      el.select('desc').text(desc);
            
      var rect = el.select('rect.background')
                  .attr('width', background != null ? width * scale : null)
                  .attr('height', background != null ? height * scale : null);      
            
      // Never transition
      el.attr('class', classed);

      var g = el.select(_impl.child());
            
      if (transition === true) {
        el = el.transition(context);
        g = g.transition(context);
        rect = rect.transition(context);
      }     

      // Transition if enabled
      el.attr('width', width * scale)
        .attr('height', height * scale)
        .attr('viewBox', '0 0 ' + width + ' ' + height);
    
      g.attr('transform', 'translate(' + left + ',' + top + ')');

      rect.attr('fill', background);

    });
  }

  _impl.self = function() { return 'svg' + (id ?  '#' + id : ''); };
  _impl.child = function() { return inner; };
  _impl.childDefs = function() { return 'defs'; };
  _impl.childWidth = function() { return innerWidth; };
  _impl.childHeight = function() { return innerHeight; };

  _impl.id = function() {
    return id;
  };
    
  _impl.classed = function(value) {
    return arguments.length ? (classed = value, _impl) : classed;
  };

  _impl.style = function(value) {
    return arguments.length ? (style = value, _impl) : style;
  };

  _impl.background = function(value) {
    return arguments.length ? (background = value, _impl) : background;
  };
    
  _impl.width = function(value) {
    if (!arguments.length) { return width; }
    width = value;
    _updateInnerWidth();
    return _impl;
  };

  _impl.height = function(value) {
    if (!arguments.length) { return width; }
    height = value;
    _updateInnerHeight();
    return _impl;
  };
  
  _impl.scale = function(value) {
    return arguments.length ? (scale = value, _impl) : scale;
  };

  _impl.title = function(value) {
    return arguments.length ? (title = value, _impl) : title;
  };  

  _impl.desc = function(value) {
    return arguments.length ? (desc = value, _impl) : desc;
  };   
  
  _impl.role = function(value) {
    return arguments.length ? (role = value, _impl) : role;
  };  
   
  _impl.margin = function(value) {
    if (!arguments.length) { return {
      top: top,
      right: right,
      bottom: bottom,
      left: left
    }; }
    if (value.top !== undefined) {
      top = value.top;
      right = value.right;
      bottom = value.bottom;
      left = value.left; 
    } else {
      top = value;
      right = value;
      bottom = value;
      left = value;
    }     
    _updateInnerWidth();
    _updateInnerHeight();
    return _impl;
  };
    
  return _impl;
}

// Random color from theme, optionally derived from the input 's'

// Informed by the Cagatay Demiralp paper, grey is moved around to break
// brown and red in this color scheme

var presentation10dark = [ 
    '#00ce5c', // Green
    '#d800a2', // Pink          
    '#00d9d2', // Aqua     
    '#AF5100', // Brown         
    '#bfbfbf', // Grey   
    '#DE0000', // Red     
    '#F0DE00', // Yellow           
    '#9200ff', // Purple      
    '#ED9200', // Orange     
    '#00aeff' // Blue 
];

var presentation10std = [ 
   
    '#56d58e', // Green
    '#d95cba', // Pink          
    '#63eae4', // Aqua     
    '#C78348', // Brown         
    '#d6d6d6', // Grey 
    '#E06363', // Red     
    '#FFF741', // Yellow           
    '#965ede', // Purple      
    '#FCBB54', // Orange  
    '#73c5eb' // Blue 
];

var presentation10light = [ 
    '#a5e6c3', // Green
    '#eda3da', // Pink          
    '#9af8f4', // Aqua     
    '#EDC19C', // Brown         
    '#e5e5e5', // Grey 
    '#F5AAAA', // Red     
    '#F7EFC3', // Yellow           
    '#c6a8ef', // Purple      
    '#F8D296', // Orange     
    '#addbf0' // Blue 
];

var names10 = {
    green:  0,
    pink:   1,
    aqua:   2,        
    brown:  3,
    grey:   4,
    red:    5,
    yellow: 6,
    purple: 7,
    orange: 8,
    blue:   9
};

var presentation10 = {
    standard: presentation10std,
    darker: presentation10dark,
    lighter: presentation10light,
    names: names10    
};

 

   

var display = { 
    light : {
        background: '#ffffff',
        text: '#262626',
        axis: '#262626',
        grid: '#e0e0e0',
        highlight: 'rgba(225,16,16,0.5)',
        lowlight: 'rgba(127,127,127,0.3)',
        shadow: 'rgba(127,127,127,0.4)',
        fillOpacity: 0.33,
        negative: {
            background: 'rgba(0, 0, 0, 0.66)',
            text: '#ffffff'
        }
    },
    dark : {
        background: '#333333',    
        text: '#ffffff',
        axis: '#ffffff',
        grid: '#6d6d6d',
        highlight: 'rgba(225,16,16,0.5)',
        lowlight: 'rgba(127,127,127,0.5)',
        shadow: 'rgba(255,255,255,0.4)',
        fillOpacity: 0.33,      
        negative: {
            background: 'rgba(255, 255, 255, 0.85)',
            text: '#262626'
        }
    }
};

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)

var widths = {
    outline: 0.5,
    data: 2.5,
    axis: 1.0,
    grid: 2.0
};

// Fallback here chooses system fonts first
var systemFontFallback = "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"";

function sizeForWidth(width) {
    if (width < 414) {
        return '12px';
    }
    return '14px';
}

var fonts = {
    fixed: {
        cssImport: "@import url(https://fonts.googleapis.com/css?family=Source+Code+Pro:300,500);",
        weightMonochrome: 300,
        weightColor: 500,
        sizeForWidth: sizeForWidth,
        family: "\"Source Code Pro\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace" // Font fallback chosen to keep presentation on places like GitHub where Content Security Policy prevents inline SRC
    },
    variable: {
        cssImport: "@import url(https://fonts.googleapis.com/css?family=Raleway:400,500);",
        weightMonochrome: 400,
        weightColor: 500,
        sizeForWidth: sizeForWidth,
        family: ("\"Raleway\", \"Trebuchet MS\", " + systemFontFallback)
    },
    brand: {
        cssImport: "@import url(https://fonts.googleapis.com/css?family=Electrolize);",
        weightMonochrome: 400,
        weightColor: 400,
        sizeForWidth: sizeForWidth,
        family: ("\"Electrolize\", " + systemFontFallback)
    }
};

/**
 * Copyright (c) 2016Redsift Limited. All rights reserved.
*/
// import { axisBottom, axisLeft, axisRight, axisTop } from 'd3-axis';
// import { units, time } from '@redsift/d3-rs-intl';
var DEFAULT_ASPECT = 160 / 420;
var DEFAULT_INSET = 24;
var DEFAULT_AXIS_PADDING = 8;
var EMPTY_COLOR = '#f2f2f2';
var timeMap = {
  timeSecond: [d3Time.timeSecond, d3Time.timeSeconds],
  timeMinute: [d3Time.timeMinute, d3Time.timeMinutes],
  timeHour: [d3Time.timeHour, d3Time.timeHours],
  timeDay: [d3Time.timeDay, d3Time.timeDays],
  timeWeek: [d3Time.timeWeek, d3Time.timeWeeks],
  timeSunday: [d3Time.timeSunday, d3Time.timeSundays],
  timeMonday: [d3Time.timeMonday, d3Time.timeMondays],
  timeTuesday: [d3Time.timeTuesday, d3Time.timeTuesdays],
  timeWednesday: [d3Time.timeWednesday, d3Time.timeWednesdays],
  timeThursday: [d3Time.timeThursday, d3Time.timeThursdays],
  timeFriday: [d3Time.timeFriday, d3Time.timeFridays],
  timeSaturday: [d3Time.timeSaturday, d3Time.timeSaturdays],
  timeMonth: [d3Time.timeMonth, d3Time.timeMonths],
  timeYear: [d3Time.timeYear, d3Time.timeYears],
  utcSecond: [d3Time.utcSecond, d3Time.utcSeconds],
  utcMinute: [d3Time.utcMinute, d3Time.utcMinutes],
  utcHour: [d3Time.utcHour, d3Time.utcHours],
  utcDay: [d3Time.utcDay, d3Time.utcDays],
  utcWeek: [d3Time.utcWeek, d3Time.utcWeeks],
  utcSunday: [d3Time.utcSunday, d3Time.utcSundays],
  utcMonday: [d3Time.utcMonday, d3Time.utcMondays],
  utcTuesday: [d3Time.utcTuesday, d3Time.utcTuesdays],
  utcWednesday: [d3Time.utcWednesday, d3Time.utcWednesdays],
  utcThursday: [d3Time.utcThursday, d3Time.utcThursdays],
  utcFriday: [d3Time.utcFriday, d3Time.utcFridays],
  utcSaturday: [d3Time.utcSaturday, d3Time.utcSaturdays],
  utcMonth: [d3Time.utcMonth, d3Time.utcMonths],
  utcYear: [d3Time.utcYear, d3Time.utcYears]
};

function chart(id) {

  var classed = 'squares-chart',
      theme = 'light',
      background = undefined,
      style = undefined,
      inset = null,
      zfield = null,
      starting = 'timeSunday',
      intervalIndex = null,
      intervalValue = null,
      rangeIndex = null,
      rangeValue = null,
      tickAxisFormatIndex = null,
      tickAxisFormatValue = null,
      dateFormat = d3TimeFormat.timeFormat('%Y-%m-%d'),
      dateIdFormat = d3TimeFormat.timeFormat('%Y%U'),
      monthSeparation = true,
      nice = true,
      minDate = null,
      maxDate = null,
      D = function (d) { return d3TimeFormat.timeParse('%Y-%m-%d')(d) || new Date(d); },
      DT = function (d) { return D(d).getTime(); },
      dayWeekNum = function (d) { return D(d).getDay(); },
      dayMonthNum = function (d) { return D(d).getDate(); },
      dayHourFormat = d3TimeFormat.timeFormat('%w-%-H'),
      isFirstMonth = function (d) { return dayMonthNum(d) === 1; },
      translate = function (x,y) { return ("translate(" + x + "," + y + ")"); },
      colorScale = function () { return EMPTY_COLOR; },
      squareY = function (_,i) { return i * cellSize; },
      dI = function (d) { return d; },
      dX = function (d) { return d.x; },
      dY = function (d) { return d.y; },
      dZ = function (d) { return d.z; },
      xAxisText = dI,
      yAxisText = dI, 
      columnId = dI,
      yAxisData = [],
      xAxisData = [],
      xLabelAnchor = 'middle',
      xLabelBaseline = '',
      xLabelTranslate = translate,
      animationDirection = -1,
      margin = 26,
      width = 600,
      height = null,
      type = 'matrix',
      subType = null,
      scale = 1.0,
      calendarColumn = 8,
      cellSize = 10,
      color = 'green',
      onClick = null;

  var palette = function (c) {
    if(Array.isArray(c)){
      return c;
    }
    return [
      presentation10.lighter[presentation10.names[c]],
      presentation10.standard[presentation10.names[c]],
      presentation10.darker[presentation10.names[c]]  
    ];
  };
  function fullCalendar(dataByDate){
    if(dataByDate.size() === 0){
      maxDate = maxDate || Date.now();
      minDate = minDate || d3Time.timeMonth.offset(Date.now(), -2);
    }
    var _extent = d3Array.extent(Array.from(dataByDate.keys(), DT));
    var _minDate = DT(minDate) || _extent[0];
    var _maxDate = DT(maxDate) || _extent[1];
    var tMD = timeMap[starting][0];
    var tM = starting.indexOf('utc') > -1 ? d3Time.utcMonth : d3Time.timeMonth;
    var tD = starting.indexOf('utc') > -1 ? d3Time.utcDay : d3Time.timeDay;

    if(nice){
      // show whole months
      _minDate = tM(_minDate);
      _maxDate = tD.offset(tM.offset(tM(_maxDate),1),-1);
    }

    var weekScale = d3Scale.scaleTime()
      .domain([tMD.offset(_minDate, -1), _maxDate])
      .ticks(tMD,1);

    if(!nice){
      _minDate = tD(_minDate);
    }

    var weekFirstDay = function (d) { return Math.max(_minDate, DT(d)); };
    var weekLastDay = function (d) { return Math.min(_maxDate, tD.offset(tMD.offset(d, 1), -1)); };
    var dayScale = function (s) { return d3Scale.scaleTime()
      .domain([weekFirstDay(s), weekLastDay(s)])
      .ticks(tD, 1); };


    var result = [];
    weekScale.map(function (weekDay) {
        var temp = [];
        if(weekFirstDay(weekDay) > weekLastDay(weekDay)) { return; }
        dayScale(weekDay).map(function (d) {
          if(monthSeparation && isFirstMonth(d)){
            if(temp.length > 0){
              result.push(temp.slice(0));
              temp = [];
            }else {
              result.push([]);
            }
          }
          temp.push({ 
            x: dateFormat(d),
            z: dataByDate.get(dateFormat(d)) || 0
          });
        });
        result.push(temp);
      }
    );
    return result;
  }

  function hourCalendar(data, inset){
    var tMD = timeMap[starting][0];

    var dataByDayHour = d3Collection.nest()
      .key(function (d) { return dayHourFormat(D(d.d)); })
      .rollup(function (d) { return d3Array.sum(d, function (g) { return g.v; }); })
      .map(data);
    colorScale = d3Scale.scaleQuantize()
        .domain(d3Array.extent(dataByDayHour.entries(), function (d) { return d.value; }))
        .range(palette(color));

    columnId = function (d,i) { return i; };


    dX = function (d,i) { return i+d.x; };

    // Just get a Date object at 00:00 hours, the date doesn't matter and it's only for the axis values
    // Date.now is in local time so no need for UTC conversion.
    var aSunday = tMD(Date.now());
    xAxisData = d3Time.timeHours(d3Time.timeDay.offset(aSunday,-1), d3Time.timeDay(aSunday));
    xAxisText = function (d) { return d3TimeFormat.timeFormat('%H')(D(d)); };

    // Just get a Date object to calculate a week starting at the specified day of the week
    // No UTC needed only for axis display
    yAxisData = d3Time.timeDays(tMD.offset(tMD(Date.now()), -1), tMD(Date.now()));
    yAxisText = function (d) { return d3TimeFormat.timeFormat('%a')(D(d))[0]; };

    var dhMatrix = d3Array.range(24).map(function (h) { return d3Array.range(7).map(function (wd) {
          // here we can apply the local format the user might have chosen
          var weekDay = d3TimeFormat.timeFormat('%a')(yAxisData[wd]);
          var hourDay = d3TimeFormat.timeFormat('%H')(xAxisData[h]);
          return {
            x: [weekDay, '@', hourDay].join(' '),
            z: dataByDayHour.get([wd,'-',h].join('')) || 0
          }
        }); }
      );

    var extra = DEFAULT_AXIS_PADDING + margin + inset.left + inset.right;
    cellSize = (width - extra) / dhMatrix.length;
    heightCalc(null, inset);

    return dhMatrix;
  }

  function heightCalc(override, inset){
    var _inset = inset ? inset.top + inset.bottom : 0;
    var extra = DEFAULT_AXIS_PADDING + margin + _inset;
    var suggestedHeight = calendarColumn * cellSize;
    // check for the stricter constraint
    if(height && suggestedHeight > (height-extra)){
      cellSize = (height - extra) / calendarColumn;
    }else{
      height = +override || (suggestedHeight + extra);
    }
  }

  function dateValueCalc(data, inset){
    data = data || [];
    var retroDate = function (d) { return d ? (d.d || d.x) : null; };
    var retroValue = function (d) { return (+d.v || +(dZ(d))); };
    var tMD = timeMap[starting][0];
    var checkStarting = dayWeekNum(tMD(Date.now()));
    var dataByDate = d3Collection.nest()
      .key(function (d) { return dateFormat(D(retroDate(d))); })
      .rollup(function (d) { return d3Array.sum(d, retroValue); })
      .map(data);

    colorScale = d3Scale.scaleQuantize()
        .domain(d3Array.extent(dataByDate.entries(), function (d) { return d.value; }))
        .range(palette(color));

    columnId = function (d,i) {
      if(d && d.length < 1){
        return ("s" + i);
      }
      var t = dateIdFormat(D(retroDate(d[0])));
      return d.length < 7 && isFirstMonth(retroDate(d[0])) ? (t + "b") : t;
    };
    // used for squares and yAxis
    squareY = function (d) {
      var v = d.x || d;
      var e = dayWeekNum(v) - checkStarting + (dayWeekNum(v) < checkStarting ? 7 : 0);
      // console.log(timeFormat('%a')(D(v)), dayWeekNum(v), e)
      return e * cellSize
    };

    data = fullCalendar(dataByDate);
    // edge case when the first of the month is the first element of the chart
    data = data[0].length < 1 ? data.slice(1) : data;
    var monthNames = data
        .map(function (d,i) { return ({order: i, d: retroDate(d[0])}); })
        .filter(function (d) { return d && dayMonthNum(d.d) <= 7 && dayWeekNum(retroDate(d)) === checkStarting; } );
    xAxisData = monthNames;
    xAxisText = function (d) { return d3TimeFormat.timeFormat('%b')(D(retroDate(d))); };
    dX = function (d) { return dateFormat(D(retroDate(d))); };

    yAxisData = d3Time.timeDays(tMD.offset(tMD(Date.now()), -1), tMD(Date.now()));

    yAxisText = function (d) { return d3TimeFormat.timeFormat('%a')(D(d))[0]; };

    var extra = DEFAULT_AXIS_PADDING + margin + inset.left + inset.right;
    cellSize = (width - extra) / data.length;
    heightCalc(null, inset);

    return data;
  }

  function coocCalc(data){
    if(!data || data.length < 1){
      data = [{x:'a',y:'b',z:0}];
    }
    var matrix = [];
    var set = new Set();

    // get unique x and y
    data.forEach(function (v){  
      set.add(dX(v));
      set.add(dY(v));
    });

    var nodes = Array.from(set);
    var p ={};
    nodes.map(function (v) { p[v]={}; });
    nodes.map(function (y) {
      nodes.map(function (x) {
        p[y][x] = 0; 
        p[x][y] = 0; 
        });
    });
    data.forEach(function (v) { 
      p[dY(v)][dX(v)] = zfield ? dZ(v)[zfield] : dZ(v);
    });
    matrix = nodes.map(function (y) { return nodes.map(function (x) { return ({
        x: x,
        y: y,
        z: p[x][y]
      }); }); }
    );

    yAxisData = nodes;
    xAxisData = nodes;

    return matrix;
  }

  function matrixCalc(data){
    if(!data || data.length < 1){
      data = [{x:'a',y:'b',z:0}];
    }
    var matrix = [];
    var setX = new Set();
    var setY = new Set();

    var intFn = function (propCheck) { return Array.isArray(propCheck) ? propCheck 
      : timeMap.hasOwnProperty(propCheck) ? timeMap[propCheck] 
      : null; };
    var _xInt = intFn(intervalIndex);
    var _yInt = intFn(intervalValue);

    var fmtFn = function (propCheck) { return !propCheck ? dI 
        : typeof propCheck === 'function' ? propCheck 
        : d3TimeFormat.timeFormat(propCheck); }; 
    var _xFmt = fmtFn(tickAxisFormatIndex);
    var _yFmt = fmtFn(tickAxisFormatValue);


    var rangeFn = function (propCheck) { return typeof propCheck === 'function' ? propCheck
      : timeMap.hasOwnProperty(propCheck) ? timeMap[propCheck][0]
      : null; };

    if(_xInt && rangeIndex){

      var tU = d3Time.timeDay;
      var _xRangeCount = 1;
      if(Array.isArray(rangeIndex)){
        tU = rangeFn(rangeIndex[0]);
        _xRangeCount = rangeIndex[1];
      }else{
        tU = rangeFn(rangeIndex);
      }

      var _xIDs = function (d) { return _xFmt(_xInt[0](d)); };
      var tUs = _xInt[1];
      var _xRange = tUs(tU(Date.now()), tU.offset(tU(Date.now()), _xRangeCount));
      _xRange.map(function (k) { 
        setX.add(_xIDs(k)); 
      });
      dX = function (d) { return _xIDs(d.x); };

      if(_yInt && _yFmt){
        var _yRangeCount = 1;
        var tU$1 = d3Time.timeHour;
        if(Array.isArray(rangeValue)){
          tU$1 = rangeFn(rangeValue[0]);
          _yRangeCount = rangeValue[1];
        }else{
          tU$1 = rangeFn(rangeValue);
        }
        var tUs$1 = _yInt[1];
        var _yRange = tUs$1(tU$1(Date.now()), tU$1.offset(tU$1(Date.now()), _yRangeCount));
        var _yIDs = function (d) { return _yFmt(_yInt[0](d)); };
        _yRange.map(function (k) {
          setY.add(_yIDs(k));
        });
        dY = function (d) { return _yIDs(d.y); };
      }
    }

    // get unique x and y
    data.forEach(function (v) {
      setX.add(dX(v));
      setY.add(dY(v));
    });

    var nodesX = Array.from(setX);
    var nodesY = Array.from(setY);
    var p ={};
    nodesX.map(function (x) {
      p[x] = p[x] || {};
      nodesY.map(function (y) {
        p[x][y] = 0;
        });
    });
    data.forEach(function (v) { 
      p[dX(v)][dY(v)] = zfield ? dZ(v)[zfield] : dZ(v);
    });
    matrix = nodesX.map(function (x) { return nodesY.map(function (y) { return ({
        x: x,
        y: y,
        z: p[x][y]
      }); }); }
    );
    yAxisData = nodesY;
    xAxisData = nodesX;
    return matrix;
  }

  function xyzCalc(data, inset){
    var matrix = subType === 'cooc' ? coocCalc(data) : matrixCalc(data);

    colorScale = d3Scale.scaleQuantize()
        .domain([
          d3Array.min(matrix, function (d) { return d3Array.min(d, dZ); }),
          d3Array.max(matrix, function (d) { return d3Array.max(d, dZ); })
          ])
        .range(palette(color));

    var _w = width - (DEFAULT_AXIS_PADDING + margin + inset.left + inset.right);
    var _h = height - (DEFAULT_AXIS_PADDING + margin + inset.top + inset.bottom);
    cellSize = Math.min(
      _w / matrix.length,
      _h / (subType === 'cooc' ? matrix.length : matrix[0].length)
    );
    columnId = function (d,i) { return d && d.length > 1 ? dY(d[0]) : i; };
    xLabelAnchor = 'start';
    xLabelBaseline = 'middle';
    xLabelTranslate = function (x,y) { return ((translate(x,y)) + "rotate(-90)"); };

    return matrix;
  }

  function _impl(context) {
    var selection = context.selection ? context.selection() : context,
        transition = (context.selection !== undefined);

    var _background = background;
    if (_background === undefined) {
      _background = display[theme].background;
    }

    var _inset = inset;
    if (_inset == null) {
      _inset = { top: DEFAULT_INSET, bottom: 0, left: DEFAULT_INSET, right: 0 };
      // if (axisValue === 'left') {
      //   _inset.left = DEFAULT_INSET;
      // } else {
      //   _inset.right = DEFAULT_INSET;
      // }
    } else if (typeof _inset === 'object') {
      _inset = { top: _inset.top, bottom: _inset.bottom, left: _inset.left, right: _inset.right };
    } else {
      _inset = { top: _inset, bottom: _inset, left: _inset, right: _inset };
    }

    selection.each(function(data) {
      height = height || Math.round(width * DEFAULT_ASPECT);
      var tst = [type, subType].join('.');
      var types ={
        'calendar.days': dateValueCalc,
        'calendar.hours': hourCalendar
      };
      data = types[tst] ? types[tst](data, _inset) : xyzCalc(data, _inset);
      var node = d3Selection.select(this);
      // SVG element
      var sid = null;
      if (id) { sid = 'svg-' + id; }
      var root = svg(sid).width(width).height(height).margin(margin).scale(scale).background(_background);
      var tnode = node;
      if (transition === true) {
        tnode = node.transition(context);
      }
      tnode.call(root);
      var snode = node.select(root.self());
      var rootG = snode.select(root.child());

      var elmS = rootG.select(_impl.self());
      if (elmS.empty()) {
        elmS = rootG.append('g').attr('class', classed);
        //.attr('id', id);
      }

      var column = elmS.selectAll('g.column').data(data, columnId);
      var eColumn = column.exit();
      column = column.enter()
          .append('g')
          .attr('class', 'column')
          //.attr('id', columnId)
          .attr('transform', function (_,i) { return translate( animationDirection*(_inset.left + (++i * cellSize)+width), _inset.top + DEFAULT_AXIS_PADDING); })
        .merge(column);

      var square = column.selectAll('.square').data(dI, dX);
      var eSquare = square.exit();
      square = square.enter()
          .append('rect')
            .attr('class', 'square')
            .attr('width', cellSize)
            .attr('height', cellSize)
            .attr('data-x', dX)
            .attr('x', animationDirection*(_inset.left + margin + width))
            .attr('y', squareY)
            .attr('fill', function (d) { return dZ(d) ? colorScale(dZ(d)) : EMPTY_COLOR; })
          .merge(square);


      var yAxis = elmS.selectAll('.ylabels').data(yAxisData, dI);
      var eYAxis = yAxis.exit();
      yAxis = yAxis.enter()
          .append('text')
          .attr('class','ylabels')
          .attr('transform', translate( animationDirection*(_inset.left +width), cellSize/2 + DEFAULT_AXIS_PADDING + _inset.top ))
        .merge(yAxis);


      var xAxis = elmS.selectAll('.xlabels').data(xAxisData, function (d) { return (d.d || d); });
      var eXAxis = xAxis.exit();
      xAxis = xAxis.enter()
        .append('text')
          .attr('class', 'xlabels')
          .attr('transform', function (d,i) { return xLabelTranslate( animationDirection*(_inset.left + (d.order || i) * cellSize + width), _inset.top); })
        .merge(xAxis);

      if (transition === true) {
        column = column.transition(context);
        eColumn = eColumn.transition(context);
        square = square.transition(context);
        eSquare = eSquare.transition(context);
        xAxis = xAxis.transition(context);
        eXAxis = eXAxis.transition(context);
        yAxis = yAxis.transition(context);
        eYAxis = eYAxis.transition(context);
      }

      column.attr('transform', function (_,i) { return translate( _inset.left + (i * cellSize), _inset.top + DEFAULT_AXIS_PADDING); });
      eColumn.attr('transform', function (_,i) { return translate( animationDirection*(_inset.left + (++i * cellSize)+width), _inset.top + DEFAULT_AXIS_PADDING); })
        .remove();
      square.attr('y', squareY)
          .attr('width', cellSize)
          .attr('height', cellSize)
          .attr('x', 0)
          .attr('fill', function (d) { return dZ(d) ? colorScale(dZ(d)) : EMPTY_COLOR; });

      if(onClick){
        square.on('click', function (d) { return onClick(d); });
      }

      eSquare.attr('width', cellSize)
            .attr('height', cellSize)
            .attr('data-x', dX)
            .attr('x', animationDirection*(_inset.left + margin + width))
            .attr('y', squareY)
            .attr('fill', function (d) { return dZ(d) ? colorScale(dZ(d)) : EMPTY_COLOR; })
          .remove();

      xAxis.attr('transform', function (d,i) { return xLabelTranslate( _inset.left + (d.order || i) * cellSize, _inset.top); })
        .text(xAxisText)
        .attr('line-height', cellSize);

      if(type === 'matrix'){
        xAxis.attr('y', cellSize/2);
        xAxis.attr('x', 0);
      }else {
        xAxis.attr('x', cellSize/2);
      }

      if(type === 'calendar' && subType === 'days'){
        eXAxis.attr('x', animationDirection*width);
      }else{
        eXAxis.attr('x', height);
      }
      eXAxis.remove();

      yAxis.attr('transform', translate( _inset.left, cellSize/2 + DEFAULT_AXIS_PADDING + _inset.top ))
          .text(yAxisText)
          .attr('y', squareY)
          .attr('x', -DEFAULT_AXIS_PADDING)
          .attr('line-height', cellSize);
      
      eYAxis.attr('x', animationDirection*width)
        .remove();

      var _style = style;
      if (_style == null) {
        _style = _impl.defaultStyle();
      }

      var defsEl = snode.select('defs');
      var styleEl = defsEl.selectAll('style').data(_style ? [ _style ] : []);
      styleEl.exit().remove();
      styleEl = styleEl.enter().append('style').attr('type', 'text/css').merge(styleEl);
      styleEl.text(_style);

    });
  }
  _impl.self = function() { return 'g' + (id ?  '#' + id : '.' + classed); };

  _impl.id = function() { return id; };
  
  _impl.defaultStyle = function () { return ("\n                  //" + (fonts.variable.cssImport) + "\n                  //" + (fonts.fixed.cssImport) + "  \n\n                  " + (_impl.self()) + " text { \n                                        //font-family: " + (fonts.fixed.family) + ";\n                                        font-size: " + (fonts.fixed.sizeForWidth(width)) + ";\n                                        font-weight: " + (fonts.fixed.weightMonochrome) + "; \n                                        fill: " + (display[theme].text) + "; \n                                      }\n                  " + (_impl.self()) + " text.xlabels {\n                                        text-anchor: " + xLabelAnchor + ";\n                                        alignment-baseline: " + xLabelBaseline + ";\n                                      }\n                  " + (_impl.self()) + " text.ylabels {\n                                        text-anchor: end;\n                                        alignment-baseline: middle;\n                                      }\n                  " + (_impl.self()) + " .square {\n                                        stroke: " + (display[theme].background) + ";\n                                        stroke-width: " + (widths.grid) + ";\n                  }\n                "); };

  _impl.classed = function(_) {
    return arguments.length ? (classed = _, _impl) : classed;
  };

  _impl.background = function(_) {
    return arguments.length ? (background = _, _impl) : background;
  };

  _impl.theme = function(_) {
    return arguments.length ? (theme = _, _impl) : theme;
  }; 

  _impl.width = function(_) {
    return arguments.length ? (width = +_, _impl) : width;
  };

  _impl.height = function(_) {
    if(!arguments.length){
      return height;
    }
    heightCalc(_);

    return _impl
  };

  _impl.margin = function(_) {
    return arguments.length ? (margin = +_, _impl) : margin;
  };

  _impl.scale = function(_) {
    return arguments.length ? (scale = _, _impl) : scale;
  }; 

  _impl.minDate = function(_) {
    return arguments.length ? (minDate = +_, _impl) : minDate;
  };

  _impl.maxDate = function(_) {
    return arguments.length ? (maxDate = +_, _impl) : maxDate;
  };

  _impl.color = function(_) {
    return arguments.length ? (color = _, _impl) : color;
  };

  _impl.type = function(_) {
    if(!arguments.length){
      return subType ? [type, subType].join('.') : type ;
    }
    var s = _.split('.');
    type = s[0];
    subType = s.length > 1 ? s[1] : null;

    return _impl
  };

  _impl.style = function(_) {
    return arguments.length ? (style = _, _impl) : style;
  };

  _impl.starting = function(_) {
    return arguments.length ? 
      timeMap.hasOwnProperty(_) ? (starting = _, _impl) : _impl
      : starting;
  };

  _impl.inset = function(_) {
    return arguments.length ? (inset = _, _impl) : inset;
  };

  _impl.zfield = function(_) {
    return arguments.length ? (zfield = _, _impl) : zfield;
  };

  _impl.cellSize = function(_) {
    return arguments.length ? (cellSize = _, _impl) : cellSize;
  };

  _impl.intervalIndex = function(_) {
    return arguments.length ? (intervalIndex = _, _impl) : intervalIndex;
  };
  
  _impl.intervalValue = function(_) {
    return arguments.length ? (intervalValue = _, _impl) : intervalValue;
  };
  
  _impl.rangeIndex = function(_) {
    return arguments.length ? (rangeIndex = _, _impl) : rangeIndex;
  };
  
  _impl.rangeValue = function(_) {
    return arguments.length ? (rangeValue = _, _impl) : rangeValue;
  };
  
  _impl.tickAxisFormatIndex = function(_) {
    return arguments.length ? (tickAxisFormatIndex = _, _impl) : tickAxisFormatIndex;
  };
  
  _impl.tickAxisFormatValue = function(_) {
    return arguments.length ? (tickAxisFormatValue = _, _impl) : tickAxisFormatValue;
  };

  _impl.onClick = function(value) {
    return arguments.length ? (onClick = value, _impl) : onClick;
  };

  _impl.monthSeparation = function(_){
    return arguments.length ? (monthSeparation = _, _impl) : monthSeparation;
  };

  _impl.nice = function(_){
    return arguments.length ? (nice = _, _impl) : nice;
  };

  return _impl;
}

exports.version = version;
exports.html = chart;

Object.defineProperty(exports, '__esModule', { value: true });

})));
